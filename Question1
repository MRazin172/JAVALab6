import java.util.concurrent.*;

class coin implements Callable<Integer> {
    private final int[] coins;
    private final int sum;
    private final int start;
    private final int end;

    public coin(int[] coins, int sum, int start, int end) {
        this.coins = coins;
        this.sum = sum;
        this.start = start;
        this.end = end;
    }

    @Override
    public Integer call() {
        int[] dp = new int[sum + 1];
        dp[0] = 1;

        for (int i = start; i < end; i++) {
            for (int j = coins[i]; j <= sum; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }

        return dp[sum];
    }
}

public class Main {
    public static int findCoinCombinations(int[] coins, int sum, int numThreads) throws InterruptedException, ExecutionException {
        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
        int partitions = coins.length / numThreads;
        int remaining = coins.length % numThreads;

        int start = 0;
        int end = partitions;

        // Create a list to hold Future objects
        Future<Integer>[] futures = new Future[numThreads];

        // Divide the work among threads
        for (int i = 0; i < numThreads; i++) {
            if (i == numThreads - 1) {
                end += remaining;
            }
            coin task = new coin(coins, sum, start, end);
            futures[i] = executor.submit(task);
            start = end;
            end += partitions;
        }

        int totalWays = 0;
        // Get results from all threads and sum up the total ways
        for (Future<Integer> future : futures) {
            totalWays += future.get();
        }

        // Shutdown the executor
        executor.shutdown();
        return totalWays;
    }

    public static void main(String[] args) {
        int[] coins = {1, 2, 5};
        int sum = 5;
        int numThreads = 3;

        try {
            int totalCombinations = findCoinCombinations(coins, sum, numThreads);
            System.out.println("Total combinations: " + totalCombinations);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
